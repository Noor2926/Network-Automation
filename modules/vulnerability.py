import json
import logging
import socket
import concurrent.futures
import datetime
from pathlib import Path
from typing import Dict, List, Any, Union

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("network_scanner.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("vulnerability")

# Constants
VULNERABILITIES_DIR = Path("data/vulnerabilities")

# Ensure directory exists
VULNERABILITIES_DIR.mkdir(parents=True, exist_ok=True)

# Common vulnerabilities to check
COMMON_VULNERABILITIES = [
    {
        "name": "Open SSH",
        "port": 22,
        "description": "SSH port is open, which could allow remote access if not properly secured.",
        "severity": "Medium",
        "recommendation": "Ensure SSH is properly configured with key-based authentication and disable password authentication."
    },
    {
        "name": "Open Telnet",
        "port": 23,
        "description": "Telnet port is open, which transmits data in plaintext and is considered insecure.",
        "severity": "High",
        "recommendation": "Disable Telnet and use SSH instead."
    },
    {
        "name": "Open FTP",
        "port": 21,
        "description": "FTP port is open, which may transmit credentials in plaintext.",
        "severity": "Medium",
        "recommendation": "Use SFTP or FTPS instead of FTP, or ensure anonymous access is disabled."
    },
    {
        "name": "Open SMB",
        "port": 445,
        "description": "SMB port is open, which could be vulnerable to various exploits if not patched.",
        "severity": "High",
        "recommendation": "Ensure SMB is properly configured and patched to the latest version."
    },
    {
        "name": "Open RDP",
        "port": 3389,
        "description": "RDP port is open, which could allow remote desktop access if not properly secured.",
        "severity": "Medium",
        "recommendation": "Use a VPN or firewall to restrict RDP access, enable Network Level Authentication, and use strong passwords."
    },
    {
        "name": "Open MySQL",
        "port": 3306,
        "description": "MySQL database port is open to the network.",
        "severity": "Medium",
        "recommendation": "Restrict MySQL access to localhost or use a firewall to limit access."
    },
    {
        "name": "Open PostgreSQL",
        "port": 5432,
        "description": "PostgreSQL database port is open to the network.",
        "severity": "Medium",
        "recommendation": "Restrict PostgreSQL access to localhost or use a firewall to limit access."
    },
    {
        "name": "Open MSSQL",
        "port": 1433,
        "description": "Microsoft SQL Server port is open to the network.",
        "severity": "Medium",
        "recommendation": "Restrict MSSQL access to localhost or use a firewall to limit access."
    },
    {
        "name": "Open Redis",
        "port": 6379,
        "description": "Redis database port is open to the network.",
        "severity": "High",
        "recommendation": "Redis should not be exposed to the internet. Restrict access to localhost or use a firewall."
    },
    {
        "name": "Open MongoDB",
        "port": 27017,
        "description": "MongoDB database port is open to the network.",
        "severity": "High",
        "recommendation": "MongoDB should not be exposed to the internet. Restrict access to localhost or use a firewall."
    }
]

def check_port_open(ip: str, port: int, timeout: float = 1.0) -> bool:
    """Check if a port is open on a given IP address."""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        result = sock.connect_ex((ip, port))
        sock.close()
        
        return result == 0
    except Exception as e:
        logger.error(f"Error checking port {port} on {ip}: {str(e)}")
        return False

def scan_vulnerabilities(ip: str, timeout: float = 1.0) -> Dict[str, Any]:
    """Scan for vulnerabilities on a given IP address."""
    try:
        logger.info(f"Starting vulnerability scan for {ip}")
        
        vulnerabilities = []
        
        # Check each vulnerability
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            # Create a dictionary of futures to vulnerabilities
            future_to_vuln = {
                executor.submit(check_port_open, ip, vuln["port"], timeout): vuln 
                for vuln in COMMON_VULNERABILITIES
            }
            
            # Process results as they complete
            for future in concurrent.futures.as_completed(future_to_vuln):
                vuln = future_to_vuln[future]
                try:
                    is_open = future.result()
                    if is_open:
                        vulnerabilities.append(vuln)
                except Exception as e:
                    logger.error(f"Error processing vulnerability check for {vuln['name']}: {str(e)}")
        
        # Save results to file
        save_vulnerability_results(ip, vulnerabilities)
        
        logger.info(f"Vulnerability scan completed for {ip}. Found {len(vulnerabilities)} potential vulnerabilities.")
        
        return {
            "status": "success",
            "ip": ip,
            "vulnerabilities": vulnerabilities,
            "total": len(vulnerabilities)
        }
    
    except Exception as e:
        logger.error(f"Error scanning vulnerabilities for {ip}: {str(e)}")
        return {
            "status": "error",
            "message": f"Failed to scan vulnerabilities: {str(e)}"
        }

def save_vulnerability_results(ip: str, vulnerabilities: List[Dict[str, Any]]) -> None:
    """Save vulnerability scan results to a file."""
    try:
        vuln_file = VULNERABILITIES_DIR / f"{ip.replace('.', '_')}.json"
        
        vuln_data = {
            "ip": ip,
            "timestamp": str(datetime.datetime.now()),
            "vulnerabilities": vulnerabilities
        }
        
        with open(vuln_file, 'w') as f:
            json.dump(vuln_data, f)
        
        logger.info(f"Vulnerability scan results saved for {ip}")
    
    except Exception as e:
        logger.error(f"Error saving vulnerability scan results for {ip}: {str(e)}")

def get_vulnerability_results(ip: str) -> Dict[str, Any]:
    """Get saved vulnerability scan results for a given IP address."""
    try:
        vuln_file = VULNERABILITIES_DIR / f"{ip.replace('.', '_')}.json"
        
        if not vuln_file.exists():
            return {
                "status": "no_data",
                "message": "No vulnerability scan data available"
            }
        
        with open(vuln_file, 'r') as f:
            vuln_data = json.load(f)
        
        return {
            "status": "success",
            "ip": ip,
            "vulnerabilities": vuln_data.get("vulnerabilities", []),
            "timestamp": vuln_data.get("timestamp")
        }
    
    except Exception as e:
        logger.error(f"Error getting vulnerability scan results for {ip}: {str(e)}")
        return {
            "status": "error",
            "message": f"Failed to get vulnerability scan results: {str(e)}"
        }
